// Automatically generated by MockGen. DO NOT EDIT!
// Source: store.go

package kv

import (
	gomock "github.com/golang/mock/gomock"
)

// Mock of Store interface
type MockStore struct {
	ctrl     *gomock.Controller
	recorder *_MockStoreRecorder
}

// Recorder for MockStore (not exported)
type _MockStoreRecorder struct {
	mock *MockStore
}

func NewMockStore(ctrl *gomock.Controller) *MockStore {
	mock := &MockStore{ctrl: ctrl}
	mock.recorder = &_MockStoreRecorder{mock}
	return mock
}

func (_m *MockStore) EXPECT() *_MockStoreRecorder {
	return _m.recorder
}

func (_m *MockStore) Put(key string, value []byte, opts ...PutOption) error {
	_s := []interface{}{key, value}
	for _, _x := range opts {
		_s = append(_s, _x)
	}
	ret := _m.ctrl.Call(_m, "Put", _s...)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockStoreRecorder) Put(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	_s := append([]interface{}{arg0, arg1}, arg2...)
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Put", _s...)
}

func (_m *MockStore) AtomicPut(key string, value []byte, expected *KeyValue, opts ...PutOption) (*KeyValue, error) {
	_s := []interface{}{key, value, expected}
	for _, _x := range opts {
		_s = append(_s, _x)
	}
	ret := _m.ctrl.Call(_m, "AtomicPut", _s...)
	ret0, _ := ret[0].(*KeyValue)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockStoreRecorder) AtomicPut(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	_s := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return _mr.mock.ctrl.RecordCall(_mr.mock, "AtomicPut", _s...)
}

func (_m *MockStore) Get(key string) (*KeyValue, error) {
	ret := _m.ctrl.Call(_m, "Get", key)
	ret0, _ := ret[0].(*KeyValue)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockStoreRecorder) Get(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Get", arg0)
}

func (_m *MockStore) List(prefix string) ([]*KeyValue, error) {
	ret := _m.ctrl.Call(_m, "List", prefix)
	ret0, _ := ret[0].([]*KeyValue)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockStoreRecorder) List(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "List", arg0)
}

func (_m *MockStore) Delete(key string) error {
	ret := _m.ctrl.Call(_m, "Delete", key)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockStoreRecorder) Delete(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Delete", arg0)
}

func (_m *MockStore) AtomicDelete(key string, expected *KeyValue) (bool, error) {
	ret := _m.ctrl.Call(_m, "AtomicDelete", key, expected)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockStoreRecorder) AtomicDelete(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "AtomicDelete", arg0, arg1)
}

func (_m *MockStore) DeleteTree(prefix string) error {
	ret := _m.ctrl.Call(_m, "DeleteTree", prefix)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockStoreRecorder) DeleteTree(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "DeleteTree", arg0)
}

func (_m *MockStore) Exists(key string) (bool, error) {
	ret := _m.ctrl.Call(_m, "Exists", key)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockStoreRecorder) Exists(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Exists", arg0)
}

func (_m *MockStore) Watch(key string, stopCh <-chan struct{}) (<-chan *KeyValue, error) {
	ret := _m.ctrl.Call(_m, "Watch", key, stopCh)
	ret0, _ := ret[0].(<-chan *KeyValue)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockStoreRecorder) Watch(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Watch", arg0, arg1)
}

func (_m *MockStore) WatchTree(prefix string, stopCh <-chan struct{}) (<-chan []*KeyValue, error) {
	ret := _m.ctrl.Call(_m, "WatchTree", prefix, stopCh)
	ret0, _ := ret[0].(<-chan []*KeyValue)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockStoreRecorder) WatchTree(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "WatchTree", arg0, arg1)
}

func (_m *MockStore) Lock(key string, opts ...LockOption) (Locker, error) {
	_s := []interface{}{key}
	for _, _x := range opts {
		_s = append(_s, _x)
	}
	ret := _m.ctrl.Call(_m, "Lock", _s...)
	ret0, _ := ret[0].(Locker)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockStoreRecorder) Lock(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	_s := append([]interface{}{arg0}, arg1...)
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Lock", _s...)
}

func (_m *MockStore) Close() {
	_m.ctrl.Call(_m, "Close")
}

func (_mr *_MockStoreRecorder) Close() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Close")
}

// Mock of Locker interface
type MockLocker struct {
	ctrl     *gomock.Controller
	recorder *_MockLockerRecorder
}

// Recorder for MockLocker (not exported)
type _MockLockerRecorder struct {
	mock *MockLocker
}

func NewMockLocker(ctrl *gomock.Controller) *MockLocker {
	mock := &MockLocker{ctrl: ctrl}
	mock.recorder = &_MockLockerRecorder{mock}
	return mock
}

func (_m *MockLocker) EXPECT() *_MockLockerRecorder {
	return _m.recorder
}

func (_m *MockLocker) Lock(stopChan chan struct{}) (<-chan struct{}, error) {
	ret := _m.ctrl.Call(_m, "Lock", stopChan)
	ret0, _ := ret[0].(<-chan struct{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockLockerRecorder) Lock(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Lock", arg0)
}

func (_m *MockLocker) Unlock() error {
	ret := _m.ctrl.Call(_m, "Unlock")
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockLockerRecorder) Unlock() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Unlock")
}
